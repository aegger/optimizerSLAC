# -*- coding: iso-8859-1 -*-

import numpy as np
from numpy.random import rand
from scipy.interpolate import griddata # for interpolating data on a grid for the maps
from corrplot import *
from fitcorrplot import *
        
# an interface that interpolates a function over a grid over a certain domain and extrapolates based on a fit outside of that domain
class CorrplotInterface(object):
    def __init__(self, pathToCorrPlotFile, fitOnlyQ=False, drunkenQ=False): 
	# takes a corrplot .mat file pathToCorrPlotFile
	
	# set up interpolation
	
	# import data
	[nby4arrayoffloats, legend] = corrplot(pathToCorrPlotFile) # read in corrplot data
	nby4arrayoffloats = np.transpose(nby4arrayoffloats);
	
	self.pvs = legend;
	self.pvdict = dict() # for simple lookup
	for i in range(len(self.pvs)):
	    self.pvdict[self.pvs[i]] = i # objective fcn is last here
	    
	print "\nPVs imported from correlation plot data:"
	for pv in legend: print(pv)
	print
	
	# takes a numpy array of grid points with cols x, y, mean(fel), stdev(fel)
        self.points = nby4arrayoffloats[:,:2]
        self.means = nby4arrayoffloats[:,2]
        self.stdevs = nby4arrayoffloats[:,3]
        self.mins = [min(self.points[:,a]) for a in range(len(self.points[0]))];
        self.maxes = [max(self.points[:,a]) for a in range(len(self.points[0]))];
        
        print("mins = " + str(self.mins))
        print("maxes = " + str(self.maxes))
        
        #print('CorrplotInterface: self.points = ' + str(self.points))
        #print('CorrplotInterface: self.means = ' + str(self.means))
        #print('CorrplotInterface: self.stdevs = ' + str(self.stdevs))
        #if len(nby4arrayoffloats[0]) == 4:
        #    self.stdevs = [a[3] for a in nby4arrayoffloats]
        #else:
        #    self.stdevs = [0 for a in nby4arrayoffloats]
        # seems like in fint, he wants to store the last random number generated by the last fcn call so let's store it
        #self.x = [0, 0]
        self.x = np.array([18.,-16.5],ndmin=2)
        self.y = -1.
        self.mean = 0
        self.stdev = 0
        self.noise = self.stdev
        self.drunkenQ = drunkenQ
        self.noiseScaleFactor = 1.;
        self.fitOnlyQ = fitOnlyQ;
        
        # set up extrapolation
        
        # fit binormal variate distribution and return params
        # note params order: ['amp','xm','sx','ym','sy','rho']
        fitparams2 = fitcorrplot(pathToCorrPlotFile)
        self.mean_amp = fitparams2[0]
        self.mean_xm = fitparams2[1]
        self.mean_sx = fitparams2[2]
        self.mean_ym = fitparams2[3]
        self.mean_sy = fitparams2[4]
        self.mean_rho = fitparams2[5]
        
        # repeat the fit for the distribution of fluctuations instead
        fitparams = fitcorrplot(pathToCorrPlotFile, fitNoiseQ=True)
        self.stdev_amp = fitparams[0]
        self.stdev_xm = fitparams[1]
        self.stdev_sx = fitparams[2]
        self.stdev_ym = fitparams[3]
        self.stdev_sy = fitparams[4]
        self.stdev_rho = fitparams[5]
        self.stdev_bg = fitparams[6]
        
    # simple access fcn
    def get1(self, pvname):
        
        index = self.pvdict[pvname]
        if index == len(self.pvs)-1:
            self.getState()
            if hasattr(self.y, '__iter__'):
                return self.y[0]
            else:
                return self.y
        else:
            return self.x[-1,index]
        
    # simple access fcn
    def set1(self, pvname, value):
	index = self.pvdict[pvname]
	if index == len(self.pvs)-1:
            self.y = value
	else:
            self.x[-1,index] = value
        
    # interpolating function
    def fin(self, x_new): # let this method update means and stdevs
	#print("interpolation")
        self.x = x_new
        grid_x, grid_y = np.mgrid[self.x[0,0]:1:1j, self.x[0,1]:1:1j]
        self.mean = griddata(self.points, self.means, (grid_x, grid_y), method='cubic')[0][0]
        self.stdev = griddata(self.points, self.stdevs, (grid_x, grid_y), method='cubic')[0][0]
        
        # set result mean (perturb by noise below)
        self.y = self.mean
        
        # set noise
	self.noise = abs(self.noiseScaleFactor * self.stdev) + 1.e-10; # small number needed to prevent requesting stdev of 0 in np.random.normal
	self.noise = np.random.normal(0., self.noise, self.y.shape)
	#self.noise = self.noise * (self.y > 0) # zero noise where the mean is negative
	
	# NOTE: maybe need a uniform background noise level for the noise fit
	
	# perturb mean by noise
	self.y = self.y + self.noise  # zero noise where the mean is 
	    
        return np.array(self.y, ndmin=2)
        
    # extrapolating function
    def fex(self, x_new): # let this method update means and stdevs
	#print("extrapolation")
        self.x = x_new
        x = np.array([te[0] for te in x_new])
        y = np.array([te[1] for te in x_new])
	
	amp = self.mean_amp
	xm = self.mean_xm
	sx = self.mean_sx
	ym = self.mean_ym
	sy = self.mean_sy
	rho = self.mean_rho
	self.mean = amp * np.exp(-0.5*((x-xm)*(x-xm)/sx/sx+(y-ym)*(y-ym)/sy/sy-2.*rho*(x-xm)*(y-ym)/sx/sy)/(1.-rho*rho))
	
	#bg = self.stdev_bg # need to modify fitcorrplot to get this
	amp = self.stdev_amp
	xm = self.stdev_xm
	sx = self.stdev_sx
	ym = self.stdev_ym
	sy = self.stdev_sy
	rho = self.stdev_rho
	bg = self.stdev_bg
        self.stdev = bg + amp * np.exp(-0.5*((x-xm)*(x-xm)/sx/sx+(y-ym)*(y-ym)/sy/sy-2.*rho*(x-xm)*(y-ym)/sx/sy)/(1.-rho*rho))
        
        # set result mean (perturb by noise below)
        self.y = self.mean
        
        # set noise
	self.noise = abs(self.noiseScaleFactor * self.stdev) + 1.e-10; # small number needed to prevent requesting stdev of 0 in np.random.normal
	self.noise = np.random.normal(0., self.noise, self.y.shape)
	#self.noise = self.noise * (self.y > 0) # zero noise where the mean is negative
	
	# NOTE: maybe need a uniform background noise level for the noise fit
	
	# perturb mean by noise
	self.y = self.y + self.noise  # zero noise where the mean is 
	    
        return np.array(self.y, ndmin=2)
        
    # wrapper function to decide based on domain
    #def finex(self, x_new):
    def f(self, x_new):
	if self.fitOnlyQ:
	    return self.fex(x_new)
        else:
	    #decide whether inside or outside the domain
	    withinQ = 0*x_new[0];
	    #print(withinQ)
	    for i in range(len(withinQ)):
		if (self.mins[i] <= x_new[0][i]) & (x_new[0][i] <= self.maxes[i]):
		    withinQ[i] = 1;
	    withinQ = np.prod(withinQ); # if all coords are within the interp range prod is 1 else 0
	    #print(withinQ)
	    #print(np.prod(withinQ))
	    #exit()
	    #return self.fex(x_new)
	    if(withinQ):
		return self.fin(x_new)
	    else:
		return self.fex(x_new)
        
    # wrapper function to decide extrapolation vs interpolation plus extrapolation
    #def f(self, x_new):
        #if self.fitOnlyQ:
	    #return self.fex(x_new)
        #else:
	    #return self.finex(x_new)
        
    def getState(self): # see note at top regarding 
        #return self.x, self.y, self.mean, self.stdev
        #return self.x, self.f(self.x)
        #return np.array(self.x, ndmin = 2), self.fex(self.x)
	return np.array(self.x, ndmin = 2), self.f(self.x)
        
    def setX(self, x_new):
        self.x = x_new
        #print("BasicInterfaces.CorrplotInterface.setX: self.x = " + str(self.x))
        if(self.drunkenQ and np.random.uniform() < 0.05):
	    self.x = x_new + np.transpose([np.random.normal(0,0.25*self.mean_sx,len(x_new)),np.random.normal(0,0.25*self.mean_sy,len(x_new))])
	    print("BasicInterfaces.CorrplotInterface.setX: self.x = " + str(self.x) + " (stutter)")
	    
	    
	    
